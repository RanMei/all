vm: {
	uid: 1,
	$options: {},
	_self: vm,

	$parent:
	$root:
	$children:
	_watcher: 
	_isMounted: false,

	_events: [],

	_watchers: [],

	name: 
	get:
	set:
	
	__proto__: {
		_init:
	}
}

data: {
	__ob__: observer,

}

observer: {
	value: data,
	dep: {
		id: 0,
		subs: [watcher,watcher,...]
	},
	__proto__: {
		walk: 
	}
}

watcher: {
	vm: ,
	id: 0,
	expression: ' loggedIn?true:false ',
	callback: ,
	deps: [],
	getter: 
	__proto__: {
		addDep: ,
	}
}

function Observer

function Watcher

function Dep
// the current target watcher being evaluated.
Dep.target = null;

function Vue
// add some methods to Vue.prototype
initMixin(Vue)
	Vue.prototype._init = 
stateMixin(Vue)
	Object.defineProperty(Vue.prototype, '$data', dataDef)
	Vue.prototype.$set = 
	Vue.prototype.$delete = 
	Vue.prototype.$watch =
eventsMixin(Vue)
	Vue.prototype.$on =
lifecycleMixin(Vue)
	Vue.prototype._mount =
	Vue.prototype.$destroy =
renderMixin(Vue)
	Vue.prototype._render =
initGlobalAPI(Vue)
	Object.defineProperty(Vue, 'config', configDef)
	Vue.options = Object.create(null)
	initUse(Vue)
		Vue.use = 
	initMixin(Vue)
		Vue.mixin =
	initExtend(Vue)
	initAssetRegisters(Vue)


// create a Vue instance
Vue(options)
	_init(options)
		vm._uid = 
		vm.$options = mergeOptions(parent,options||{},vm)
		vm._self = vm
		initLifecycle
			vm.$parent = 
			vm.$root =
			vm.$children = [];
			vm.isMounted = false;
		initEvents
			vm._updateListeners = 
		callHook(vm,'beforeCreate')
		initState(vm)
			vm._watchers = [];
			initProps(vm)

			initData(vm)
				var data = vm.$options.data;
				data = vm._data = 
				var keys = Object.keys(data);
				while(i--)
					// connect vm[key] with vm._data[key]
					proxy(vm,keys[i])
						Object.defineProperty(vm,key,{

						})
				// create an observer for data
				observe(data)
					if (!isObject(data)) {
						return
					}
					var ob;
					ob = new Observer(data);
						var observer = this;
						observer.value = data;
						// create a dependency representing data
						// which is actually useless
						// observer.dep
						// observer.dep.subs = [watcher,watcher,...]
						observer.dep = new Dep();
							dep_data.id = 
							// create subscriber
							dep_data.subs = [];
						// data.__ob__
						def(data, '__ob__', this)
						// 
						observer.walk(data)
							defineReactive(data, key, data[key])
								// create a new dependency representing data[key]
								var dep_of_data_key = new Dep();
								// create a new observer for data[key] 
								// if it is a plain object or an array
								var childObserver = observe(data[key])
    							// create getter and setter for data[key]
    							// start observe the changing of data[key]
								Object.defineProperty(data, key, {})
									*********
									// when data[key] was used,
									// which means that data[key] became a dependency for a watcher
									// push the watcher into dep_key.subs
									if (Dep.target) {
										dep_key.depend()
											if (Dep.target) {
												var watcher = Dep.target
												watcher.addDep(dep_key)
													dep_key.subs.push(watcher)
									*********
									// when data[key] was changed
									// the setter of data[key] was invoked
									data[key].set(newVal)
										// create a new observer to replace the old one
										childObserver = observe(newVal);
										// notify all the watchers to update view depending on it
										dep_key.notify()
											var subs = dep_key.subs.slice();
											var watcher = subs[i];
											watcher.update();
												watcher.run();
													var value = watcher.get();
														// the current watcher is the target
														pushTarget(watcher);
															if (Dep.target) { targetStack.push(Dep.target) }
															Dep.target = watcher;
														var value = this.getter.call(this.vm, this.vm);
														popTarget();
													watcher.callback.call(wathcer.vm, value, oldValue)
									********* 
					retrun ob;
			initComputed(vm)
				Object.defineProperty(vm, key, computedSharedDefinition);
			initMethods(vm)
			initWatch(vm)
				if(vm.$options.watch)
					// create a watcher for watch[key] and
					// push it into vm._watchers
					createWatcher(vm,key,watch[key])
						vm.$watch(key,watch[key])
							const watcher = new Watcher(vm,key,watch[key])
								var watcher = this;
								watcher.vm = vm;
								vm._watchers.push(this);
								watcher.expression = expOrFn.toString();
								watcher.cb = watch[key];
								watcher.id = ++uid;
								if (typeof expOrFn === 'function') {
									watcher.getter = expOrFn
								} else {
									watcher.getter = parsePath(expOrFn)
								watcher.value = this.get();
									pushTarget(watcher)
										if (Dep.target) { targetStack.push(Dep.target) }
										Dep.target = watcher;
									var value = watcher.getter.call(watcher.vm, watcher.vm);


		callHook(vm,'created')
			vm.$emit('created')
		initRender(vm)
			if (vm.$options.el) {
				vm.$mount(vm.$options.el)
					if (!options.render) {
						var template = options.template;
						if (template) {
						if (template) {
							var ref = compileToFunctions(template, {
								var ast = parse(template.trim(), options);
									parseHTML()
										
								optimize(ast, options);
				vm._mount()
					callHook(vm, 'beforeMount')
					// create a watcher for vm
					vm._watcher = new Watcher(vm, function () {
						vm._update(vm._render(), hydrating)
					}, noop);
					*********
					reactiveSetter
					*********